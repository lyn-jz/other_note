## 数据库三范式
- 第一范式(1NF)
  - 表中的列只能含有原子性(不可再分)的值。
- 第二范式(2NF)
  - 满足第一范式
  - 非主属性没有部分依赖。部分依赖例如：F={C->A,BC->D}，A部分依赖于主码
- 第三范式(3NF)
  - 满足第二范式
  - 非主属性没有传递依赖。传递依赖例如：F={BC->D,D->E}，主码传递依赖于D
- BCNF
  - 满足第三范式
  - 消除了主属性对候选码的部分和传递函数依赖

## 事务ACID
1. 原子性（Atomicity）
事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
2. 一致性（Consistency）
数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
3. 隔离性（Isolation）
一个事务所做的修改在最终提交以前，对其它事务是不可见的。
4. 持久性（Durability）
一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

## 并发一致性问题
- 丢失修改：两个事务一起修改数据，一个修改丢失
- 读脏数据：一个事务获取了修改的数据，获取之后数据又回滚
- 不可重复读：事务1读取数据，之后数据被修改，再读取一次结果与上次不同
- 幻影读：事务1读取某范围的数据，之后数据中被插入新数据，事务1再次读取结果与上次不同

## 封锁粒度
Database、Table、Page、Row

## 封锁类型
1. 读写锁
  - 排它锁（Exclusive），简写为 X 锁，又称写锁。
  - 共享锁（Shared），简写为 S 锁，又称读锁。
2. 意向锁：支持多粒度封锁，在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。

## 封锁协议
1. 三级封锁协议
2. 两段锁协议：加锁和解锁分为两个阶段进行

## 隔离级别
- 未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。
- 提交读（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
- 可重复读（REPEATABLE READ）（默认）：保证在同一个事务中多次读取同样数据的结果是一样的。
- 可串行化（SERIALIZABLE）：强制事务串行执行。

