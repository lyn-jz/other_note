sql（结构化查询语句）分为两部分DDL（数据定义语言）和DML（数据操纵语言）
注意：sql对大小写不敏感，语句以分号结尾
DML：select 、 update、  insert into、   delete
##### select：查询表数据 
基础用法：select  （distinct）列名  from 表名 where 条件   
- 在列名前加distinc关键字客去除重复项
- 条件中可使用and  、or 、between关键字；
- 可使用order by 列名（desc） 对查询结果排序，默认是升序，可使用desc关键字进行逆序排序；
- limit n,m 表示从第n项开始的m项  limit 3,2 c查询第四条和第五条记录  limit n，查询前n条记录 
- like运算符和通配符/REGEXP和正则表达式（待整理）一起使用，常用在where 语句中过滤符合要求的记录
- select的使用顺序 select->from-> where-> group by->having->order by

函数用法：
- 聚合函数 max（列名）、min（列名）、avg（列名）、len（列名）、first（列名）、last（列名）举例:select max(haha) from 表名   计算表中haha列的最大值
- group by 列名  与聚合函数组合使用，对表中的记录按照列名进行分组
- having 函数的出现： 聚合函数不能和where 关键字组合使用

多表查询：
1. select  列名 from 表名  on 表名 join 条件
2. inner join   left join   right join
3. 内连接与外连接的区别
   - 内连接（inner join）是取两个表的交集
   -  外连接包括 左连接、右连接、完整外部连接（full join）
      1. 左连接结果集是左表的所有记录，如果左表在右表中无记录，则设置为空
      2. 右连接结果集是右表的所有记录，与左连接类似
      3. full join 结果集是左表和右表的所有记录，对于不匹配行，都设置为空

##### update、delete、insert into
- update 表名 set 列名=新值 where 条件
- delete：删除表中符合条件的记录 delete  from  表名 where 条件
- insert into ：向表中插入记录  insert into 表名 （列名，列名，列名)  value（值，值，）（列名，列名，列名)这个字段可写可不写

#####  DDL：create、drop、alter
create:
1. create  database 数据库名
2. create  表名{
   列名  数据类型  not null
   primary key（列名）/constraint pk_表名 primary key（列名，列名）
   unique（列名）/constraint  uc_表名 unique (列名，列名)
   check  （条件）/constraint chk_表名 check（多个条件组合） 
}

drop：
1. ALTER TABLE table_name DROP INDEX index_name
2. drop table 表名
3. drop  database 数据库名
4. truncate table 表名  仅删除表中数据，不删除表结构

alter：
alter  table table_name

##### 索引分为聚集索引和非聚集索引  主键索引、唯一性索引、
- 索引的优缺点：
  - 优点：
    1.加快查询速度。
    2.创建唯一索引可确保数据的唯一性。
    3.在使用分组和排序的子语句中可明显减少查询中分组和排序的执行时间。
  - 缺点：
    1.创建索引和维护索引需要时间。
    2.索引占据物理空间。
- 使用索引的场景：
  1.经常使用where 子语句的列
  2.经常查询的数据列。
  3.主键（聚集索引） 聚集在物理空间上。
  4.经常出现在 group by 、order by、distinct关键词后的数据列。
  5.经常用于连接的数据列，加快连接速度。
- 不使用索引的场景:
  1.很少的数据项。
  2.不经常使用的数据项。
  3.经常要存取的数据列。
  聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致
- 索引失效的情况：
  1.where子语句中索引列有运算。
  2.where子语句索引列使用了函数。
  3.where子语句中使用了 or 其中有索引的列索引不会生效。
  4.对于复合索引，如果前列字段不使用，后列字段的索引不会生效。
  5.索引列存在类型转换。
  6.索引列使用Like操作符且第一个通配符是%
  
- 创建索引 sql
  - CREATE （类型）INDEX 索引 ON TABLE （列名）
  #### 类型可以为不填（普通索引)、PRIMARY KEY、UNIQUE
- sql优化
  1.建立索引
  2.使用大写
  
### 死锁
- 定义：两个及以上进程因竞争资源而发生相互等待的情况称为死锁。举例，a线程（用户）访问A表（资源），加锁对其加锁，然后访问B表（资源）；b线程（用户）访问B表（资源），对其加锁，然后访问A表（资源）
这时候a需要等b释放B才能继续，b需要等a释放A才能继续，两个线程互相等待
- 必要条件：
  1. 资源在某一时刻只能为一个进程所有（互斥条件）
  2. 当进程为请求资源而阻塞时不释放已有资源（请求和保持）
  3. 对于进程所获得的资源，在使用完之前不能被剥夺，只能在使用完后自行释放（不剥夺）
  4. 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链
- 预防死锁：破坏产生死锁的必要条件之一
  1.一次性分配所有资源（破坏请求条件）
  2.只要由一个资源未得到，也不给该进程分配其他资源（破坏保持条件）
  3.当进程已获得部分资源而得不到其他资源时，剥夺其已有资源（破坏剥夺条件）
  4.系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源
- 避免死锁：
  银行家算法：对于某一进程的资源请求，先试探为其分配资源，判断系统是否处于安全状态，如果系统处于安全状态，那么为其分配，如果不处于安全状态，那么使进程处于等待状态
  1. if request[i][j] <need[i][j]
  2. if requst[i][j] <available[j]
  3. 试探分配：
     更新avilabe[j]
     更新allocation[i][j]
     更新need[i][j]
  4. 安全监测：对于每个进程，其以后需要的资源小于系统剩余资源与当前占有资源之和
#### 事务属性（acid）
  - a 原子性：事务中的操作不可分割，要么全部完成要么全部不完成
  - c 一致性：事务前后数据的完整性必须保持一致
  - i 隔离性：多个用户并发访问数据库时，为每个用户开启一个事务，每个事务之间互不影响，并发事务之间互相隔离
  - d 持久性：事务一旦提交，那么对数据库造成的影响是永久的
#### 隔离级别
  事务的并发操作中可能会引起脏读、丢失修改、重复读、幻读等情况。不可重复读的重点是修改数据，幻读的重点是插入或者删除数据。
  - read uncommited 读未提交 最低的隔离级别，允许读取事务尚未提交的数据，可能会发生脏读、幻读、不可重复读等问题
  - read commited 读已提交  允许读取事务已经提交的数据，可防止脏读，但不可防止幻读和重复读
  - read repeatable 可重复读  对同一字段多次读取的结果是一致的，可避免脏独和不可重复读，可能会出现幻读
  - SERIALIZABLE 可串行化  所有的事务一次执行。
  
   
#### 线程和进程的连续和区别
  - 进程： 程序一次执行的动态过程，拥有独立的地址空间，是资源分配管理的基本单位
  - 线程： cpu调度和分派的基本单位，同一进程中的线程组共享进程所拥有的所有资源
  - 联系： 线程是进程的一部分，一个进程可创建多个线程，但一个线程只能属于一个进程
  - 区别：
    1. 操作系统中能同时运行多个进程，而一个进程中能同时执行多个线程(cpu调度，单个时间片能只能运行单个线程)
    2. 每个进程由独立的代码和数据空间空间，切换程序会有较大的开销；线程组共享代码和数据空间，线程切换开销较小
     
#### 进程通信的方式
   - 管道
     1.无名管道  一般用于父进程和子进程的通信
     2.命名管道   任意两个进程间均可通信
   - 消息队列
   - 信号量
   - 共享内存

#### socket
socket可用于不同计算机进程间的通信，位于应用层与传输层之间
- 服务端：
  1.socket（）建立套接字  套接字有地址族、类型族、协议这3个属性，命名socket
    类型分为TCP流式套接字和UDP数据报式套接字。 地址族有 ipv4、ipv6等
  2.bind（） 套接字与地址（ip和端口）绑定 
  3. listen（） 服务器监听客户端的连接请求：创建队列，并用其来存放来自客户端的连接。
  4. accept（） 接受客户端的连接请求，阻塞直到有连接
  5. recv()
- 客户端：
  1. socket（）创建套接字
  2. connect（）请求连接

##### 进程状态
- 创建态  为进程创建新PCB，向其中填入控制和管理进程的信息，分配进程所需的资源。如果创建工作无法完成，比如资源不满足，此时则处于创建态
- 就绪态  将创建的进程加入就绪队列，等待分配CPU，此时处于就绪态
- 运行态  进程在就绪队列中被调度，处于执行态
- 阻塞态  运行中的进程由于某些时间的发生，比如等待i/o等变的不可执行，那么此时处于阻塞态
- 终止态   进程结束运行

##### 线程同步与互斥
- 同步是指协同步调，让线程按预定的先后顺序执行。方法有：临界区、互斥对象、信号量、事件对象
- 互斥 共享的进程资源，线程在操作时具有排他性。

######   多线程并发  并发指在同一时间cpu只能处理一条指令，但是多个线程的指令被快速的轮换执行，使得宏观上有多个线程在同时执行
python 多线程编程模块：threading模块有Thread、Lock、Event、Semaphore、Condition。线程安全指在多线程环境中，共享数据在同一时间只能由一个线程来操作，保证线程安全的方式是加互斥锁。
发生死锁的情况很大部分时因为线程获得多个锁造成线程互相等待锁释放。解决方法是加锁的顺序保持一致：A线程给加a锁然后想给b加锁，B线程给b加锁然后给a加锁，互相阻塞；此时改为A先加a锁，再加b锁；B也是先加a锁再加b锁
1. Thread（）对象创建进程。该对象有属性 target（线程执行的函数）、name(线程名)、args(target中的参数)；方法有 start（启动线程） run(定义线程功能的方法，通过继承Thread类来创建线程对象时，可重写run方法)
2. Lock互斥锁 当线程调用Lock的acquire()方法获得锁时，锁就进入locked状态，此时别的线程去获得该锁时会进入blocked（阻塞）状态，只有调用release()方法释放之后才可用
3. Semaphore 信号量 当线程调用Semaphore对象的acquire（）方法时，如果内部计数器大于0，则减1，如果小于等于0，那么线程阻塞；当有线程调用release()方法时，内部计数器加1.在实例化Semaphore对象时传入参数最大课用资源数。
4. Event 事件  Event 对象内置全局标志位Flag，默认为false.线程调用wait()方法时，如果Flag为false，则线程阻塞；如果Falge为true，线程将继续执行。set()方法设置Flag为True，clear()设置flag为False。

#####  GIL：全局解释器锁，保证同一时刻只能一个线程的代码被运行
每个线程在被执行前需要获取GIL锁，然后释放GIL锁后另外的线程再获取该锁去执行代码。释放GIL的情况:i/o操作，计时器。python的多线程对i/o密集型代码（各种文件操作处理）比较友好，对cpu密集型代码（各种循环技术）不友好

##### 引用和指针的区别 
- 指针： 一个变量，存放的数据是其执行的变量的地址
